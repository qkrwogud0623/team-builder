import React, { useState } from 'react';
import { 
  Container, Typography, Box, TextField, Button, Checkbox, 
  FormControlLabel, Paper, Grid, createTheme, ThemeProvider, CssBaseline,
  Select, MenuItem, FormControl, InputLabel, IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';

// 세션 정보
const SESSIONS = {
  vocal: "보컬", guitar: "기타", bass: "베이스", drum: "드럼", keyboard: "키보드"
};
const SESSION_KEYS = Object.keys(SESSIONS);

// 다크 모드 테마
const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    secondary: { main: '#f48fb1' },
    success: { main: '#81c784' },
  },
});

// 수정 가능한 팀 결과 카드 컴포넌트
const EditableTeamCard = ({ team, teamIndex, participants, onTeamChange, onPinToggle }) => {
  return (
    <Paper variant="outlined" sx={{ p: 2, height: '100%', border: team.isPinned ? '2px solid #81c784' : '1px solid rgba(255, 255, 255, 0.23)' }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h6" color={team.isPinned ? 'success.main' : 'inherit'}>
          팀 {teamIndex + 1}
        </Typography>
        <IconButton onClick={() => onPinToggle(team.id)} color={team.isPinned ? 'success' : 'default'}>
          {team.isPinned ? <PushPinIcon /> : <PushPinOutlinedIcon />}
        </IconButton>
      </Box>
      {SESSION_KEYS.map(key => {
        const isMultiSlot = key === 'guitar' || key === 'keyboard';
        const numSlots = isMultiSlot ? 2 : 1;
        return (
          <Box key={key} sx={{ mt: 2 }}>
            <Typography variant="body2" sx={{ fontWeight: 'bold', mb: 1 }}>{SESSIONS[key]}</Typography>
            {Array.from({ length: numSlots }).map((_, slotIndex) => {
              if (isMultiSlot && slotIndex === 1 && !team.members[key][0]) return null;
              const assignedMember = team.members[key][slotIndex] || '';
              return (
                <FormControl key={slotIndex} fullWidth size="small" sx={{ mb: 1 }}>
                  <InputLabel>{SESSIONS[key]} {isMultiSlot ? slotIndex + 1 : ''}</InputLabel>
                  <Select
                    value={assignedMember}
                    label={`${SESSIONS[key]} ${isMultiSlot ? slotIndex + 1 : ''}`}
                    onChange={(e) => onTeamChange(team.id, key, slotIndex, e.target.value)}
                  >
                    <MenuItem value=""><em>- 비우기 -</em></MenuItem>
                    {participants
                      .filter(p => p.name && p.sessions.includes(key))
                      .filter(p => !(isMultiSlot && p.name === team.members[key][1 - slotIndex]))
                      .map(p => <MenuItem key={`${p.id}-${slotIndex}`} value={p.name}>{p.name}</MenuItem>)
                    }
                  </Select>
                </FormControl>
              );
            })}
          </Box>
        );
      })}
    </Paper>
  );
};

function App() {
  const [participants, setParticipants] = useState([
    { id: 1, name: '', sessions: [] }
  ]);
  const [teamCount, setTeamCount] = useState(2);
  const [generatedTeams, setGeneratedTeams] = useState(null);

  // 참여자 핸들러
  const handleAddParticipant = () => setParticipants([...participants, { id: Date.now(), name: '', sessions: [] }]);
  const handleRemoveParticipant = (id) => setParticipants(participants.filter(p => p.id !== id));
  const handleParticipantChange = (id, field, value) => {
    setParticipants(participants.map(p => {
      if (p.id === id) {
        if (field === 'name') return { ...p, name: value };
        if (field === 'sessions') {
          const newSessions = p.sessions.includes(value) ? p.sessions.filter(s => s !== value) : [...p.sessions, value];
          return { ...p, sessions: newSessions };
        }
      }
      return p;
    }));
  };

  const handleGenerateTeams = () => {
    const validParticipants = participants.filter(p => p.name && p.sessions.length > 0);
    if (validParticipants.length === 0) {
      alert("참여자를 1명 이상 입력해주세요.");
      return;
    }

    const pinnedTeams = generatedTeams ? generatedTeams.filter(t => t.isPinned) : [];
    const unpinnedTeamCount = teamCount - pinnedTeams.length;

    if (unpinnedTeamCount < 0) {
      alert("총 팀 수는 고정된 팀 수보다 적을 수 없습니다.");
      return;
    }

    const gigCounts = validParticipants.reduce((acc, p) => ({ ...acc, [p.name]: 0 }), {});
    pinnedTeams.forEach(team => {
      Object.values(team.members).flat().forEach(name => {
        if (gigCounts[name] !== undefined) gigCounts[name]++;
      });
    });

    let autoGeneratedTeams = Array.from({ length: unpinnedTeamCount }, (_, i) => ({
      id: `team-${Date.now()}-${i}`,
      members: SESSION_KEYS.reduce((acc, key) => ({ ...acc, [key]: [] }), {}),
      isPinned: false,
    }));

    // --- ▼▼▼▼▼▼▼▼▼▼ 로직 수정 부분 ▼▼▼▼▼▼▼▼▼▼ ---
    const findBestCandidate = (sessionKey, excludedNames = []) => {
      const candidates = validParticipants.filter(p => 
        p.sessions.includes(sessionKey) && !excludedNames.includes(p.name)
      );
      if (candidates.length === 0) return null;

      // 1. 후보들 중 가장 적은 참여 횟수를 찾음
      const minGigs = Math.min(...candidates.map(c => gigCounts[c.name]));
      
      // 2. 가장 적은 참여 횟수를 가진 후보들을 모두 찾음
      const bestCandidates = candidates.filter(c => gigCounts[c.name] === minGigs);

      // 3. 동점자 중에서 무작위로 한 명 선택하여 반환
      return bestCandidates[Math.floor(Math.random() * bestCandidates.length)];
    };
    // --- ▲▲▲▲▲▲▲▲▲▲ 로직 수정 부분 ▲▲▲▲▲▲▲▲▲▲ ---

    SESSION_KEYS.forEach(key => {
      for (const team of autoGeneratedTeams) {
        const candidate = findBestCandidate(key);
        if (candidate) {
          team.members[key][0] = candidate.name;
          gigCounts[candidate.name]++;
        }
      }
    });

    ['guitar', 'keyboard'].forEach(key => {
      for (const team of autoGeneratedTeams) {
        const personInFirstSlot = team.members[key][0];
        const candidate = findBestCandidate(key, [personInFirstSlot]);
        if (candidate) {
          team.members[key][1] = candidate.name;
          gigCounts[candidate.name]++;
        }
      }
    });

    setGeneratedTeams([...pinnedTeams, ...autoGeneratedTeams]);
  };

  const handleTeamChange = (teamId, sessionKey, slotIndex, newName) => {
    setGeneratedTeams(generatedTeams.map(team => {
      if (team.id === teamId) {
        const newMembers = [...team.members[sessionKey]];
        newMembers[slotIndex] = newName;
        const cleanedMembers = newMembers.filter(name => name);
        return { ...team, members: { ...team.members, [sessionKey]: cleanedMembers } };
      }
      return team;
    }));
  };

  const handlePinToggle = (teamId) => {
    setGeneratedTeams(generatedTeams.map(team => 
      team.id === teamId ? { ...team, isPinned: !team.isPinned } : team
    ));
  };

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline /> 
      <Container maxWidth="md" sx={{ my: 4 }}>
        <Typography variant="h4" component="h1" align="center" gutterBottom>
          마테시스 화이팅
        </Typography>
        
        <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
          <Typography variant="h6" gutterBottom>참여자 정보 입력</Typography>
          {participants.map((p, index) => (
            <Box key={p.id} sx={{ display: 'flex', alignItems: 'center', mb: 2, flexWrap: 'wrap', gap: 1 }}>
              <TextField label={`참여자 ${index + 1}`} variant="outlined" size="small" value={p.name} onChange={(e) => handleParticipantChange(p.id, 'name', e.target.value)} sx={{ mr: 1, minWidth: '100px' }} />
              <Box sx={{ flexGrow: 1 }}>
                {SESSION_KEYS.map(key => (
                  <FormControlLabel key={key} control={<Checkbox checked={p.sessions.includes(key)} onChange={() => handleParticipantChange(p.id, 'sessions', key)} />} label={SESSIONS[key]} />
                ))}
              </Box>
              <IconButton onClick={() => handleRemoveParticipant(p.id)} size="small" color="warning"><DeleteIcon /></IconButton>
            </Box>
          ))}
          <Button variant="contained" startIcon={<AddIcon />} onClick={handleAddParticipant}>참여자 추가</Button>
        </Paper>

        <Paper elevation={3} sx={{ p: 3, mb: 3, display: 'flex', alignItems: 'center', gap: 2 }}>
            <TextField label="총 팀 수" type="number" value={teamCount} onChange={(e) => setTeamCount(Number(e.target.value))} size="small" InputProps={{ inputProps: { min: 1 } }} />
            <Button variant="contained" color="secondary" size="large" onClick={handleGenerateTeams}>최적의 팀 생성하기</Button>
        </Paper>
        
        {generatedTeams && (
          <Paper elevation={3} sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>팀 구성 결과 (수정 및 고정 가능)</Typography>
            <Grid container spacing={2}>
              {generatedTeams.map((team, index) => (
                <Grid item xs={12} sm={6} md={4} key={team.id}>
                  <EditableTeamCard
                    team={team}
                    teamIndex={index}
                    participants={participants}
                    onTeamChange={handleTeamChange}
                    onPinToggle={handlePinToggle}
                  />
                </Grid>
              ))}
            </Grid>
          </Paper>
        )}
      </Container>
    </ThemeProvider>
  );
}

export default App;
